// Jenkinsfile for Developer Build Job (developer_build) - Uses Commit IDs - Separate Repo - Minikube URL Fix

// Define constants for services and defaults
def ALL_SERVICES = [
    "admin-server",
    "api-gateway",
    "config-server",
    "customers-service",
    "discovery-server",
    "genai-service",
    "vets-service",
    "visits-service"
]
def DEFAULT_BRANCH_OR_TAG = "main"
def DEFAULT_IMAGE_TAG = "latest"
// --- ADJUSTED DEFAULTS TO MATCH USER'S LOCAL COMMAND ---
def HELM_RELEASE_NAME = "petclinic-dev" // Updated default release name
def K8S_NAMESPACE = "petclinic-dev"    // Updated default namespace
// --- PATHS ARE RELATIVE TO THE NEW REPO CHECKOUT ---
// *** ADJUST THIS PATH based on where charts are in the NEW repo ***
def HELM_CHART_PATH = "charts/petclinic-umbrella" // Example: if charts are in 'charts/' subdir
// --- Directory for checking out App Source ---
def APP_SOURCE_DIR = "app-source" // Subdirectory name in workspace

pipeline {
    // *** Ensure agent has git, helm, kubectl, AND minikube installed ***
    agent any

    environment {
        DOCKERHUB_USERNAME = "22127422" // Still needed for potential image references in values? Verify chart usage.
        // APP_SOURCE_REPO_URL = "https://github.com/Burncake/spring-petclinic-microservices.git"
    }

    parameters {
        // --- Parameters for App Source Repo ---
        string(name: 'APP_SOURCE_REPO_URL', defaultValue: 'https://github.com/Burncake/spring-petclinic-microservices.git', description: 'Git repository URL for the application source code')
        string(name: 'APP_SOURCE_DEFAULT_BRANCH', defaultValue: 'main', description: 'Default branch of application source repo to ensure checkout works')
        // --- Service Branch Parameters (same as before) ---
        string(name: 'ADMIN_SERVER_BRANCH', defaultValue: "${DEFAULT_BRANCH_OR_TAG}", description: "Branch for admin-server ('${DEFAULT_BRANCH_OR_TAG}' uses '${DEFAULT_IMAGE_TAG}' tag)")
        // ... other service branch parameters ...
        string(name: 'VISITS_SERVICE_BRANCH', defaultValue: "${DEFAULT_BRANCH_OR_TAG}", description: "Branch for visits-service ('${DEFAULT_BRANCH_OR_TAG}' uses '${DEFAULT_IMAGE_TAG}' tag)")
    }

    options {
        buildDiscarder(logRotator(numToKeepStr: '10'))
        timestamps()
    }

    stages {
        // Stage 1: Verify Helm Chart Path (No changes)
        stage('Verify Helm Chart Path') {
            steps {
                script {
                    echo "Running from workspace: ${env.WORKSPACE}"
                    echo "Verifying Helm chart directory exists at ${HELM_CHART_PATH}..."
                    sh "ls -ld ${HELM_CHART_PATH}"
                }
            }
        }

        // Stage 2: Checkout Application Source Code (No changes)
        stage('Checkout Application Source Code') {
            steps {
                script {
                    echo "Checking out application source from ${params.APP_SOURCE_REPO_URL} into ./${APP_SOURCE_DIR} directory..."
                    dir(APP_SOURCE_DIR) {
                        deleteDir()
                        checkout([
                            $class: 'GitSCM',
                            branches: [[name: params.APP_SOURCE_DEFAULT_BRANCH]],
                            userRemoteConfigs: [[url: params.APP_SOURCE_REPO_URL]],
                        ])
                        echo "Application source checkout complete."
                    }
                }
            }
        }

        // Stage 3: Prepare Helm Deployment (Removed global.dockerhubUser)
        stage('Prepare Helm Deployment') {
            steps {
                script {
                    echo "Determining image tags and preparing Helm deployment command..."
                    def imageTagSetArgs = []
                    def gitErrors = []

                    dir(APP_SOURCE_DIR) {
                        echo "Fetching latest changes from Git remote 'origin' for Application Source..."
                        try {
                            sh 'git fetch origin --prune'
                            echo "Git fetch successful for Application Source."
                        } catch (e) {
                            error "FATAL: Failed to fetch from App Source Git remote 'origin'. Error: ${e.message}"
                        }

                        ALL_SERVICES.each { service ->
                            def paramName = "${service.toUpperCase().replace('-', '_')}_BRANCH"
                            def branchParam = params."${paramName}"?.trim() ?: DEFAULT_BRANCH_OR_TAG
                            def imageTag = ''

                            if (branchParam.equalsIgnoreCase(DEFAULT_BRANCH_OR_TAG)) {
                                imageTag = DEFAULT_IMAGE_TAG
                                echo "Service [${service}]: Parameter='${branchParam}', Using Default Image Tag='${imageTag}'"
                            } else {
                                echo "Service [${service}]: Parameter='${branchParam}', Attempting to find latest commit ID..."
                                try {
                                    def remoteBranchRef = "origin/${branchParam}"
                                    imageTag = sh(script: "git rev-parse --short ${remoteBranchRef}", returnStdout: true).trim()
                                    if (!imageTag) { throw new Exception("Commit ID resolved to empty string.") }
                                    echo "Service [${service}]: Found commit ID '${imageTag}' for branch '${branchParam}'"
                                } catch (e) {
                                    echo "ERROR: Service [${service}] Branch '${branchParam}': ${e.getMessage()}"
                                    gitErrors.add("Service [${service}] - Branch '${branchParam}': ${e.getMessage()}")
                                    imageTag = "error-commit-not-found"
                                }
                            }
                            imageTagSetArgs.add("--set ${service}.image.tag=${imageTag}")
                        } // End service loop
                    } // End dir(APP_SOURCE_DIR)

                    if (!gitErrors.isEmpty()) {
                        error "FATAL: Failed to determine commit IDs:\n - ${gitErrors.join('\n - ')}"
                    }

                    // *** Construct Helm command WITHOUT global.dockerhubUser ***
                    // Uses updated K8S_NAMESPACE and HELM_RELEASE_NAME defaults
                    def helmCmd = "helm upgrade --install ${HELM_RELEASE_NAME} ./${HELM_CHART_PATH} --namespace ${K8S_NAMESPACE} --create-namespace --wait --timeout 10m"
                    // --- REMOVED: helmCmd += " --set global.dockerhubUser=${env.DOCKERHUB_USERNAME}" ---
                    env.HELM_DEPLOY_COMMAND = "${helmCmd} ${imageTagSetArgs.join(' ')}"
                    echo "Helm command prepared:"
                    echo env.HELM_DEPLOY_COMMAND
                }
            }
        }

        // Stage 4: Deploy via Helm (No changes)
        stage('Deploy via Helm') {
            steps {
                script {
                    echo "Executing Helm deployment to namespace '${K8S_NAMESPACE}'..."
                    try {
                        sh "${env.HELM_DEPLOY_COMMAND}"
                        echo "Helm deployment successful for release '${HELM_RELEASE_NAME}'."
                    } catch (err) {
                        echo "ERROR: Helm deployment failed!"
                        echo err.getMessage()
                        currentBuild.result = 'FAILURE'
                        error("Helm deployment failed. Check Helm/Kubernetes logs.")
                    }
                }
            }
        }

        // Stage 5: Provide Access Information (Using minikube service --url)
        stage('Provide Access Information') {
            steps {
                script {
                    echo "Attempting to retrieve access URL via 'minikube service --url'..."
                    // Uses updated K8S_NAMESPACE and HELM_RELEASE_NAME defaults
                    def apiGatewayServiceName = "${HELM_RELEASE_NAME}-api-gateway" // Should be petclinic-dev-api-gateway
                    def serviceUrlCmd = "minikube service ${apiGatewayServiceName} -n ${K8S_NAMESPACE} --url"
                    try {
                        // Execute the command and capture output.
                        // Use '|| true' to prevent build failure if minikube exits non-zero
                        // after printing URL (common in non-interactive environments).
                        def serviceUrlsOutput = sh(script: "${serviceUrlCmd} || true", returnStdout: true).trim()

                        if (serviceUrlsOutput) {
                            echo "-----------------------------------------------------"
                            echo "Access the PetClinic UI via one of the following URLs:"
                            // Print each line of output, as there might be multiple URLs (http/https)
                            serviceUrlsOutput.split('\n').each { url ->
                                if (url.trim()) { // Avoid printing empty lines
                                    echo "- ${url.trim()}"
                                }
                            }
                            echo "(This URL is generated by 'minikube service' and may tunnel traffic)"
                            echo "-----------------------------------------------------"
                        } else {
                            echo "WARNING: 'minikube service --url' did not return any output for service '${apiGatewayServiceName}' in namespace '${K8S_NAMESPACE}'. Is the service running and the API gateway pod ready?"
                            echo "You might need to wait a bit and run manually: ${serviceUrlCmd}"
                            currentBuild.result = 'UNSTABLE'
                        }
                    } catch (err) {
                        echo "WARNING: Failed to execute 'minikube service --url' command."
                        echo err.getMessage()
                        echo "Please check services manually: kubectl get svc -n ${K8S_NAMESPACE}"
                        currentBuild.result = 'UNSTABLE'
                    }
                }
            }
        }
    } // End stages

    post {
        // ... same as before ...
         always {
            echo "Developer Build Pipeline finished with status: ${currentBuild.currentResult}"
            // cleanWs() // Clean workspace if desired
        }
        success {
            echo "Deployment successful."
        }
        unstable {
            echo "Deployment finished with warnings (e.g., could not get access URL automatically)."
        }
        failure {
            echo "Deployment FAILED. Check Git errors, Helm errors, or Kubernetes logs."
        }
    } // End post

} // End pipeline
